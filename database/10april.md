### Дайджест по БД (пока сидим пердим на лекции):
## Диаграмма классов
![image](https://github.com/voron5096/scribblings/assets/70198995/426b2439-ce4d-404a-aee8-5bb3c0e457d9)

- Класс control по своей сути только перенаправляет на новую класс-форму типа boundary (обычно на диаграмме его называют как "менеджер" по умолчанию), операции в нижней части как правило строятся исходя из диаграммы последовательности (смотрите ниже) 
- Класс entity это физические база данных, без "волшебных" операций. Она не может ничего включить, выключить и т.д. Она может только добавить в себя запись, исключить запись, отредактировать свои записи и прочее
- Класс boundary (граничный класс) в большинстве своём случаев это именно интерфейс, форма для заполнения данных. Например поле регистрации, поле заполнения адресов и так далее.
Обычно связан с actor, так как именно актёр с ним взаимодействует.

**Связи на диаграммах** (и не только у Диаграммы классов):
0..1 это 0 или 1 (но не более 1) и далее по списку. Примеры ниже.

Класс-сущность entity связан с накопителями DFD. Их количество должно быть одинаково на обоих диаграммах. 

**Уровни доступа:**
- `-` приватный только внутри данного класса доступно (примеров нет) 
- `#` доступно из родительских классов, либо наследников (люди с регистрацией, они имеют доступ к свои данным) 
- `+` публичный (лучше вообще не использовать, или без регистрации, анонимные пользователи доступ к которым никак не ограничивается) 
- Пакетный уровень (отображается без значков), обычно используется так: все классы одного типа добавляются в 1 пакет (одну большую БД для сервера, как пример, но и это необязательно).
Если типов много (например разные отчёты) лучше разделить их на разные пакеты. Жёстких правил нет, в одном пакете могут быть разные классы. 

**Связи:**

Ассоциация.
Однонаправленная, например датчик в пожаротушении, со стрелочкой.
Двунаправленная без всего.
Рефлексивная, например сдвиг сортировки фамилии

Зависимость (пунктир).
Один класс зависит от второго, например новый товар зависит прибыли 

Агрегация
Из всех заказов нужно выбрать определённый тип постовщика (часть из целого), ромб будет около класса который главный.

**Множественность:**

(`0..4` курса `10..20` студентов)

Другой пример `1..1` (один ровно один)

Существуют ещё некоторые **роли** (типа: +имя) на стрелке. В основном бесполезная вещь которая больше мешает чем помогает. 

## Диаграммы взаимодействия
Их всего 2:
- Последовательности
- Кооперативные

Всего на таких диаграммах 3 типа сообщения:
- информационное
- запрос
- императивное (требует действия).

## Диаграмма последовательности

![image](https://github.com/voron5096/scribblings/assets/70198995/89e70c3c-13ad-46b0-8001-8221b622b7a9)
![image](https://github.com/voron5096/scribblings/assets/70198995/11f803bf-5ece-4a79-bdd2-b35cca540daa)

Там где жизненный цикл (даже для каждого альтернативного варианта!). Сверху все варианты классов, слева actor, сами стрелки последовательность операций.

**Важно:** нужно указывать что сам актёр взаимодействиет **ТОЛЬКО** с экраном, сам экран взаимодействиет с менеджером. Сама же диаграмма опять строится исходя из выбранного **ОДНОГО** варианта использования. По умолчанию расстраиваем вариант что всё нормально.

Если есть альтернативный поток данных: (например ошибка при оплате), то создаём новую диаграмму просто копируем всё до ошибки и делаем новый выход с ошибкой.

Также ещё одна рекомендация - не забывать о **крестике**, то есть завершение операции на линии жизни (например на транзакции).

**Эту диаграмму можно и нужно использовать для построения диаграмм классов!**

## Диаграмма кооперации (кооперативная)
![image](https://github.com/voron5096/scribblings/assets/70198995/694cf544-d00f-4c7e-9143-d00f799f5edd)

Тоже самое что и диаграмма последовательности, только она показывает какие классы с какими связаны. На одной линии можно использовать несколько операций.
Эту диаграмму можно использовать также для построения методов в диаграмме классов.

## Диаграмма состояний
Их может быть много для каждого варианта использования, они строятся для объектов, то есть непосредственно классов.

Выбирается **один** класс из диаграммы взаимодействия (любого типа). 

Диаграмма показывает все состояния класса, это альтернативные варианты (например для счета, закрыть счёт, счёт может уйти в минус, быть заблокированы и т.д., только одно состояние начальное, конечных много).

В каждом состоянии мы рассматриваем все возможные события (прямоугольник и линии-события из него, условия пишем внутри линии). В состоянии пишем что нужно сделать чтобы перейти в нужное состояние.

На диаграмме есть условия. В [] пишется условие перехода (на стрелке):
- entry: что сделать
- do: как оповестить после действия (например послать СМС)
- exit: что сделать чтобы выйти из данного состояния (например если баланс стал неотрицательный).

Условие для выхода (exit) пишут на стрелке исходящей из события/состояния в квадратных скобках [].
